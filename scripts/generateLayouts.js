import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const OUTPUT_FILE = path.join(__dirname, '../supabase/migrations/20260108_add_album_layouts.sql');

// Design Constants
const GUTTER = 2; // 2%
const SAFE_ZONE = 3; // 3%
const HERO_THRESHOLD = 40; // 40% area
const CATEGORIES = ['Symmetric', 'Asymmetric', 'Negative Space'];

function generateLayouts() {
    let sql = `
-- ============================================================================
-- ALBUM LAYOUTS & TEMPLATES
-- Generated by script
-- ============================================================================

CREATE TABLE IF NOT EXISTS album_layouts (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  name TEXT NOT NULL,
  category TEXT CHECK (category IN ('Symmetric', 'Asymmetric', 'Negative Space')),
  image_count INTEGER NOT NULL CHECK (image_count BETWEEN 1 AND 10),
  aspect_ratio TEXT DEFAULT 'square', -- '1:1', '4:3', '16:9'
  config JSONB NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Enable RLS
ALTER TABLE album_layouts ENABLE ROW LEVEL SECURITY;

-- Policy: Everyone can read layouts
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_policies WHERE tablename = 'album_layouts' AND policyname = 'Everyone can read layouts'
    ) THEN
        CREATE POLICY "Everyone can read layouts" ON album_layouts FOR SELECT USING (true);
    END IF;
END
$$;

INSERT INTO album_layouts (name, category, image_count, aspect_ratio, config) VALUES
`;

    const values = [];

    // Helper to add a layout
    const add = (name, category, count, config) => {
        const json = JSON.stringify(config);
        // Escape single quotes for SQL
        values.push(`('${name}', '${category}', ${count}, '1:1', '${json}')`);
    };

    // --- Generators ---

    // 1. Symmetric Grids
    // Simple logic: Divide space evenly
    const generateGrid = (rows, cols, count) => {
        const slots = [];
        const w = (100 - (SAFE_ZONE * 2) - ((cols - 1) * GUTTER)) / cols;
        const h = (100 - (SAFE_ZONE * 2) - ((rows - 1) * GUTTER)) / rows;

        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                if (slots.length >= count) break;
                slots.push({
                    top: parseFloat((SAFE_ZONE + r * (h + GUTTER)).toFixed(2)),
                    left: parseFloat((SAFE_ZONE + c * (w + GUTTER)).toFixed(2)),
                    width: parseFloat(w.toFixed(2)),
                    height: parseFloat(h.toFixed(2)),
                    z_index: 1
                });
            }
        }
        return slots;
    };

    // 2. Asymmetric (Hero + Grid)
    // Left/Right split or Top/Bottom split where one side is bigger
    const generateHeroLayout = (count, heroPos = 'left') => {
        const slots = [];
        const isHorizontal = heroPos === 'left' || heroPos === 'right';

        let heroSize = 60; // 60% grid
        let remainingSize = 100 - heroSize - GUTTER - (SAFE_ZONE * 2);

        // Hero Slot
        const hero = {
            top: SAFE_ZONE,
            left: SAFE_ZONE,
            width: isHorizontal ? heroSize : 100 - (SAFE_ZONE * 2),
            height: isHorizontal ? 100 - (SAFE_ZONE * 2) : heroSize,
            z_index: 1
        };

        if (heroPos === 'right') hero.left = 100 - SAFE_ZONE - hero.width;
        if (heroPos === 'bottom') hero.top = 100 - SAFE_ZONE - hero.height;

        slots.push(hero);

        // Remaining slots grid
        const remainingCount = count - 1;
        if (remainingCount > 0) {
            // Fill the rest
            const startX = heroPos === 'left' ? SAFE_ZONE + heroSize + GUTTER : SAFE_ZONE;
            const startY = heroPos === 'top' ? SAFE_ZONE + heroSize + GUTTER : SAFE_ZONE;

            // For simple implementation, stack remaining simply
            const rows = remainingCount > 1 && isHorizontal ? remainingCount : 1;
            const cols = remainingCount > 1 && !isHorizontal ? remainingCount : 1;

            // Adjust for grid
            // This is a simplified filler, good enough for "seed" variation
            const gridW = isHorizontal ? remainingSize : hero.width;
            const gridH = isHorizontal ? hero.height : remainingSize;

            // If we have many items, force a grid in the remaining space
            // e.g. 5 items total, 1 hero, 4 remaining. 2x2 grid in remaining space.
            let sideCols = 1;
            let sideRows = remainingCount;

            if (remainingCount >= 4) {
                sideCols = 2;
                sideRows = Math.ceil(remainingCount / 2);
            }

            const slotW = (gridW - ((sideCols - 1) * GUTTER)) / sideCols;
            const slotH = (gridH - ((sideRows - 1) * GUTTER)) / sideRows;

            for (let i = 0; i < remainingCount; i++) {
                const r = Math.floor(i / sideCols);
                const c = i % sideCols;

                slots.push({
                    top: parseFloat((isHorizontal ? startY + (r * (slotH + GUTTER)) : (heroPos === 'bottom' ? startY + (r * (slotH + GUTTER)) : (heroPos === 'top' ? startY + (r * (slotH + GUTTER)) : startY))).toFixed(2)),
                    left: parseFloat((isHorizontal ? (heroPos === 'left' ? startX + (c * (slotW + GUTTER)) : startX + (c * (slotW + GUTTER))) : startX + (c * (slotW + GUTTER))).toFixed(2)),
                    width: parseFloat(slotW.toFixed(2)),
                    height: parseFloat(slotH.toFixed(2)),
                    z_index: 1
                });
            }
        }

        return slots;
    };


    // Generate Loop
    for (let count = 1; count <= 10; count++) {

        // 1. Basic Grid (Symmetric)
        if (count === 1) add('Full Frame', 'Symmetric', count, generateGrid(1, 1, 1));
        if (count === 2) {
            add('Side by Side', 'Symmetric', count, generateGrid(1, 2, 2));
            add('Stacked', 'Symmetric', count, generateGrid(2, 1, 2));
        }
        if (count === 3) add('Triple Column', 'Symmetric', count, generateGrid(1, 3, 3));
        if (count === 4) add('Four Square', 'Symmetric', count, generateGrid(2, 2, 4));
        if (count === 6) add('Six Grid', 'Symmetric', count, generateGrid(2, 3, 6));
        if (count === 9) add('Nine Grid', 'Symmetric', count, generateGrid(3, 3, 9));

        // 2. Hero Layouts (Asymmetric)
        if (count > 1) {
            add(`Hero Left (${count})`, 'Asymmetric', count, generateHeroLayout(count, 'left'));
            if (count < 6) add(`Hero Right (${count})`, 'Asymmetric', count, generateHeroLayout(count, 'right'));
            if (count < 6) add(`Hero Top (${count})`, 'Asymmetric', count, generateHeroLayout(count, 'top'));
            if (count < 6) add(`Hero Bottom (${count})`, 'Asymmetric', count, generateHeroLayout(count, 'bottom'));
        }

        // 3. Scrapbook / Overlapping (Asymmetric)
        // Simple distinct logic: Random positions within safe zone, slight rotations (simulated by non-grid)
        const generateScrapbook = (c) => {
            const slots = [];
            for (let i = 0; i < c; i++) {
                // Random-ish but deterministic positions for seed
                // We'll mimic a "pile" or "scatter"
                const size = 40 - (c * 2); // smaller as count increases
                const offset = 10 * i;
                slots.push({
                    top: SAFE_ZONE + offset + (i % 2 === 0 ? 0 : 5),
                    left: SAFE_ZONE + offset + (i % 3 === 0 ? 0 : 5),
                    width: size,
                    height: size * 0.8, // 4:3ish
                    z_index: i + 1,
                    rotation: (i % 2 === 0 ? 2 : -2) // Stored in config if schema allows, but for now standard schema
                });
            }
            return slots;
        };
        add(`Scrapbook Scatter (${count})`, 'Asymmetric', count, generateScrapbook(count));

        // 4. Negative Space (Minimalist)
        const generateMinimal = (c) => {
            // Just a small version of grid logic, centered with large margins
            const slots = generateGrid(1, c, c);
            return slots.map(s => ({
                ...s,
                height: s.height * 0.6, // Smaller height
                top: s.top + 20 // Pushed down
            }));
        };
        add(`Minimalist Row (${count})`, 'Negative Space', count, generateMinimal(count));

        // Fillers to reach target count
        // We'll add varations of the grid with slight adjustments
        let variety = 0;
        while (variety < 12) {
            const grid = generateGrid(Math.ceil(Math.sqrt(count)), Math.ceil(count / Math.ceil(Math.sqrt(count))), count);
            // Jiggle them slightly
            const jiggled = grid.map((s, i) => ({
                ...s,
                top: parseFloat((s.top + (variety % 2 === 0 ? 1 : 0)).toFixed(2)),
                left: parseFloat((s.left + (variety % 3 === 0 ? 1 : 0)).toFixed(2))
            }));
            add(`Grid Variation ${variety + 1}`, 'Symmetric', count, jiggled);
            variety++;
        }

    }

    sql += values.join(',\n');
    sql += ';\n';

    fs.writeFileSync(OUTPUT_FILE, sql);
    console.log(`Generated ${values.length} layouts to ${OUTPUT_FILE}`);
}

generateLayouts();
